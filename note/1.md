# 项目配置

- 修改项目名字：修改Info.plist中的Bundle Name

- 配置App Icon，注意右侧属性选择器中iOS版本号
- 删除原有启动界面，在Assets.xcassets中右击-App Icons& Launch Images-New iOS Launch Image
- TARGETS-App Icons and Launch Images-Launch Image Source-Use Assets Catalog-选择Assets-Migrate-返回Launch Image Source选择LaunchImage

#自定义LOG
Swift无main函数，所有东西都是全局有效的！
Swift无宏定义，所以不能像OC一样使用宏定义！
##配置DEBUG环境下的LOG
Build Settings -> 输入Swift compiler - Custom Flags -> 展开Other Swift Flags -> 双击DEBUG -> 添加-D DEBUG
##自定义LOG
```

/*
// 以下的写法在Swift3.0中将被废弃，改为#line这种写法
print(__LINE__) // 打印行号
print(__FUNCTION__) // 打印函数名
print(__FILE__) // 打印文件路径
*/
func WSLog<T>(message: T, file:String = #file, method:String = #function, line: Int = #line) {
    #if DEBUG
    print("\(method)[\(line)]: \(message)")
    #endif
}


```

##使用自定义LOG
    WSLog(10086)

##选项卡图片颜色
iOS8以后:
```swift
        tabBar.tintColor = UIColor.orangeColor()
```
iOS8以前:
```swift
        以上一句代码只有文字效果，没有图片效果
        需要设置imageWithRenderingMode为AlwaysOriginal
        或者在Assets.xcassets选中图片->右边属性->Render as->Original Image
```

##命名空间
- Swift中有命名空间的概念。所有的文件都有他自己的命名空间。印的控制器都有命名空间。命名空间默认就是项目的名字。
- 比如打印MainViewController实际输出Weibo.MainViewController。
- 可以在Build Settings中搜索Product Name查看或修改nameSpace。
- Info.plist中的Executable file这个key对应的值就是nameSpace。

可以动态获取命名空间
```swift
        let nameSpace = NSBundle.mainBundle().infoDictionary!["CFBundleExecutable"]
```

// 可选绑定
```swift
        if let ns = nameSpace as? String {

        }

```

as! 和 as? 的区别
as!比as?更加确定.as!直接将强转成某个类型。as?判断是否是某个类型，如果是，才转换。


##guard
guard是Swift2.0推出的语法。
Swift是强类型语言，我们可以写出很优雅的代码。
但也可以不知不觉的写出很丑陋的代码。
因为Swift存在可选类型绑定，所以代码很容易出现多层嵌套。
为了解决代码多层嵌套所带来的代码丑陋问题。Swift2.0推出了guard语法-条件语句。

###语法
```
guard 条件表达式 else {
    需要执行的语句
    return
}
```

`特点：`只有条件为假/不成立，才会执行{}里面的代码；否则直接跳过{}继续往下执行
对比if...else...条件表达式，guard条件表达式只有else的{}，减少了多层嵌套

`例子:`
```
// nameSpace是String类型吗？如果是就解包，并把结果赋值给ns
// ns是否为空/假？如果是就执行{}内代码，不是则不执行直接跳过
let nameSpace = NSBundle.mainBundle().infoDictionary!["CFBundleExecutable"]

        guard let ns = nameSpace as? String else{
            print("命名空间不存在")
            return
        }
```

`可选绑定:`

```
let url = NSURL(string: "http://www.520it.com/")
// 可选绑定: 如果url不为nil, 系统内部就会自动将解包之后的值赋值给temp, 并且只有temp有值时才会执行{}中的代码
// Swift开发中推荐这种写法
if let temp = url
{
    let request = NSURLRequest(URL: temp)
}
```

#异常处理
```
在OC中处理异常是通过传入一个NSError的指针来保存错误
Swfit中提供了专门处理异常机制 throws -> AnyObject
Swift中提供 try catch, 将有可能发生错误的代码放到do中, 如果真的发生了异常就会执行catch
try作用: 如果抛出(throws)异常, 那么就会执行catch
try!作用: 告诉一定一定没有错误, 不需要处理, 但是如果使用try!发生了错误, 那么程序就会崩溃, 开发中不推荐使用
try?作用: 告诉系统可能有错也可能没有错, 如果发生错误会返回一个nil, 如果没有发生错误, 会将数据包装成可选类型

```
`注意：`只有try才有do catch。try!和try?都没有do catch语句。

`总结：`
- try!没有do catch语句，但如果出现异常就会崩溃。
- try?没有do catch语句，如果不想处理异常，就可以用try?。因为程序出现异常就会返回nil，不会引起崩溃。
- try 有do catch语句，否则会报错。catch用于处理异常。

try!认为一定没有异常，如果程序一旦出现异常就会崩溃。try?不会处理异常，如果出现异常就会返回可选nil，不会引起崩溃（用于忽略异常和警告）如果没发生异常，会把值包装成功可选类型。try必须有do catch，否则会报错，在catch中处理异常。

```
// try
let path = NSBundle.mainBundle().pathForResource("MainVCSettings.json", ofType: nil)!
        let data = NSData.init(contentsOfFile: path)!

        do{
            let dicArr = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers)
            for dic in dicArr as! [[String:AnyObject]]
            {
                addChildViewController(dic["vcName"] as! String, image: dic["imageName"] as! String, highLightImage: dic["imageName"] as! String + "_highlighted", title: dic["title"] as! String)
            }
        } catch{
            addChildViewController("HomeTableViewController", image: "tabbar_home", highLightImage: "tabbar_home_highlighted", title: "首页")
            addChildViewController("MessageTableViewController", image: "tabbar_message_center", highLightImage: "tabbar_message_center_highlighted", title: "消息")
            addChildViewController("DiscoverTableViewController", image: "tabbar_discover", highLightImage: "tabbar_discover_highlighted", title: "发现")
            addChildViewController("ProfileTableViewController", image: "tabbar_profile", highLightImage: "tabbar_profile_highlighted", title: "我")
        }
    }

```

```
// try? 无do catch
let dicArr = try? NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers)

```

```
// try! 无do catch
let dicArr = try! NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers)

```

**PS:**
```
/*:
do while、repeat while和do
* swift 中的do...while基本用法和OC一致。OC中是do...while;。swift是repeat...while。
* Swift2.0开始do...while循环中没有do, 只有repeat, 因为do被作用异常处理
*/

var index = 0
repeat{
    print(index)
    index += 1
}while index < 10

```










